---
title: "How to split a playlist in regards to 'feels'"
author: "Yoon Sung Hong"
date: "12/6/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##1. Introduction  


I tend to add songs to my playlists a little too much. I usually add songs after 20 seconds of listening if I feel for them. My friends suggested that I create a monthly playlist to keep the songs under control, so I recently made a December playlist to start. But I like listening to older songs too; to be frank, I listen to specific songs depending on my mood. So I came to wonder: could I divide my playlist into different **moods** and **vibes** and create new playlists from them automatically?

Then I discovered that Spotify's API offers audio features such as **valence** and **danceability**. I also learned that you can pull track informations from playlists using functions such as `GET`. So, I decided to use that information and play around with the functions to see if I can obtain audio features for all the songs in my playlists. From there, it should be easy to divide the songs by the different **vibes**.

##2. Preparation  

To play with Spotify's API, we need functions such as `GET` and `POST`, available through the `httr` package. Let's load that package up, as well as `dplyr` package to help us sort some things out. 

```{r}
#loading packages
library(httr)
library(dplyr)
```

Now what we need is the client credentials. I have my client ID and secret, which I will have separately as variables for use later.

```{r echo = FALSE}
#client credentails
clientID <- 'xxxxxxxxxxxxxxxxxx'
secret <- 'xxxxxxxxxxxxxxxxxx'
```

Now let's create access token, by using `POST` function.

```{r}
response_1 <- POST(
  'https://accounts.spotify.com/api/token',
  accept_json(),
  authenticate(clientID, secret),
  body = list(grant_type = 'client_credentials'),
  encode = 'form',
  verbose()
)
#retrieving mytoken
mytoken <- content(response_1)$access_token
```

##3. Data import and manipulation
Now that we have the token, we should be able to get access to the information ot the playlist. I will also create objects for ID's relating to playlist and user. 
I will be using my own playlist for demonstration. [If you wanna have a listen, shameless plug:](http://spoti.fi/2noJteb)

```{r}
## creating ID's. For your own playlist, use your own values for these!
playlistID <- 'xxxxxxxxxxxxxxxxxx'
userID <- 'xxxxxxxxxxxxxxxxxx'
#token
hv <- paste0('Bearer ', mytoken)
#setting url for playlist
URL_playlist <- paste0('https://api.spotify.com/v1/users/', userID, 
                       '/playlists/', playlistID, '/tracks')
#fetching the info
response_playlist <- GET(url = URL_playlist, add_headers(Authorization = hv))
playlist <- content(response_playlist)
```

Playlist should now contain a lot of the information regarding every track (but not anything regarding audio feature). Let's use each of the track's ID to retrieve audio features for these songs.

```{r}
#loops for each song
#first creating a dataframe with the first song in the playlist.
#from there we can use rbind feature with for loops
songID <- playlist$items[[1]]$track$id
URL_song <- paste0('https://api.spotify.com/v1/audio-features/', songID)
response_song <- GET(url = URL_song, add_headers(Authorization = hv))
#creating a new data frame songs. This is differently named to the object used in for loop below.
songs <- as.data.frame(content(response_song))
for(i in 1:(playlist$total-1)) {
  songID <- playlist$items[[i+1]]$track$id
  URL_song <- paste0('https://api.spotify.com/v1/audio-features/', songID)
  response_song <- GET(url = URL_song, add_headers(Authorization = hv))
  song <- as.data.frame(content(response_song))
  #merging it to create a mastersheet
  songs <- rbind(songs, song)
}
#showing structure of the dataframe
str(songs)
```
**We're half done at this point.**

According to Spotify, valence is "A measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry)."

So let's use this to divide the tracks into two categories: ones with valence value higher than or equal to 0.5, ones with valence value lower than 0.5.

```{r}
happier_songs <- songs %>%
  filter(valence >= 0.5)
notashappy_songs <- songs %>%
  filter(valence < 0.5)
#displaying structures
str(happier_songs)
str(notashappy_songs)
```
Now we can use these songs' id's to find about the happy and sad tracks' names. Let's find out the names of the happy tracks. First, we need to  have a separate code chunk to recreate the token, as it has expired at this point. 

```{r}
#recreating token
response_1 <- POST(
  'https://accounts.spotify.com/api/token',
  accept_json(),
  authenticate(clientID, secret),
  body = list(grant_type = 'client_credentials'),
  encode = 'form',
  verbose()
)
mytoken <- content(response_1)$access_token
hv <- paste0('Bearer ', mytoken)
```

Now the actual work.
```{r}
#loop for happy songs
#have to start with an initial vector I can rbind to!
URL_track <- as.character(happier_songs$track_href[1])
response_track <- GET(url = URL_track, add_headers(Authorization = hv))
track <- content(response_track)
songs_happy <- track$name
#now the loop
for(i in 2:nrow(happier_songs)) {
URL_track <- as.character(happier_songs$track_href[i])
response_track <- GET(url = URL_track, add_headers(Authorization = hv))
track <- content(response_track)
name <- track$name
songs_happy <- c(songs_happy, name)
}
```

Let's now try to display the dataframes of happy songs (respectively).

####Happy Songs
```{r}
songs_happy
```

I don't know how to feel about *Talk Show Host* by *Radiohead* being identified as a happy song..



##4. Conclusion

This was my first time playing with the Spotify API, and I learned a lot in relation to using the data available on Spotify API and pulling out information using R functions. I really wanted to be able to add these happy and sad songs to designated playlists too (I even had empty happy and sad playlists ready), but was unable to quite figure out how to use `playlist-read-private` and `scope` to add the songs. Hopefully, I will be able to figure this out soon and this script would be complete, in my opinion!

Take home message: Spotify's API is a powerful tool that offers lots of data regarding the music, and power of programming can allow you to automatcally deter the way you listen to music!
